/*
 * mini-cp is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License  v3
 * as published by the Free Software Foundation.
 *
 * mini-cp is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY.
 * See the GNU Lesser General Public License  for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with mini-cp. If not, see http://www.gnu.org/licenses/lgpl-3.0.en.html
 *
 * Copyright (c)  2018. by Laurent Michel, Pierre Schaus, Pascal Van Hentenryck
 */

package minicp.ANDOR;

import minicp.cp.Factory;
import minicp.engine.core.IntVar;
import minicp.engine.core.Solver;
import minicp.search.*;
import minicp.state.StateManager;
import minicp.util.Procedure;
import minicp.util.exception.InconsistencyException;
import minicp.util.exception.NotImplementedException;

import java.util.*;
import java.util.List;
import java.util.function.Predicate;
import java.util.function.Supplier;

/**
 * Depth First Search Branch and Bound implementation
 */
public class AND_DFSearch {

    private Solver cp;
    private Supplier<Procedure[]> branching = null;
    private StateManager sm;


    private List<DFSListener> dfsListeners = new LinkedList<DFSListener>();


    private int currNodeIdId;

    /**
     * Creates a Depth First Search object with a given branching
     * that defines the search tree dynamically.
     *
     */

    public AND_DFSearch(Solver cp, Supplier<Procedure[]> branching) {
        this.cp = cp;
        this.sm = cp.getStateManager();
        this.branching = branching;
    }
    // REMOVE
    public AND_DFSearch(Solver cp) {
        this.cp = cp;
        this.sm = cp.getStateManager();
    }

    /**
     * Adds a listener that is called on each solution.
     *
     * @param listener the closure to be called whenever a solution is found
     */
    public void onSolution(Procedure listener) {
        dfsListeners.add(new DFSListener() {
            @Override
            public void solution(int pId, int id, int position) {
                listener.call();
            }
        });
    }


    public void addListener(DFSListener listener) {
        dfsListeners.add(listener);
    }

    /**
     * Adds a listener that is called whenever a failure occurs
     * and the search backtracks.
     * This happensthat when a {@link InconsistencyException} is thrown
     * when executing the closure generated by the branching.
     *
     * @param listener the closure to be called whenever a failure occurs and
     *                 the search need to backtrack
     */
    public void onFailure(Procedure listener) {
        dfsListeners.add(new DFSListener() {
            @Override
            public void fail(int pId, int id, int position) {
                listener.call();
            }
        });
    }


    private void notifySolution(int parentId, int nodeId, int position) {
        dfsListeners.forEach(l -> l.solution(parentId, nodeId, position));
    }

    private void notifyFailure(int parentId, int nodeId, int position) {
        dfsListeners.forEach(l -> l.fail(parentId, nodeId, position));
    }

    private void notifyBranch(int parentId, int nodeId, int position, int nChilds) {
        dfsListeners.forEach(l -> l.branch(parentId, nodeId, position, nChilds));
    }

    private SearchStatistics solve(AND_Branch branch, SearchStatistics statistics, Predicate<SearchStatistics> limit) {
        currNodeIdId = 0;
        sm.withNewState(() -> {
            try {
                dfs(branch,statistics, limit , -1, -1,false);
                statistics.setCompleted();
            } catch (StopSearchException ignored) {
            } catch (StackOverflowError e) {
                throw new NotImplementedException("dfs with explicit stack needed to pass this test");
            }
        });
        return statistics;
    }

    public SearchStatistics solve(AND_Branch branch,Predicate<SearchStatistics> limit) {
        SearchStatistics statistics = new SearchStatistics();
        return solve(branch,statistics, limit);
    }

    private Procedure[] Branching(Solver cp, IntVar[] Variable) {
        int idx = -1; // index of the first variable that is not fixed
        boolean axe = true;
        for (int k = 0; k < Variable.length; k++)
            if (Variable[k].size() > 1) {
                idx = k;
                break;
            }
        if (idx == -1)
            return new Procedure[0];
        else {
            IntVar qi = Variable[idx];
            int v = qi.min();
            Procedure left = () -> cp.post(Factory.equal(qi, v));
            Procedure right = () -> cp.post(Factory.notEqual(qi, v));
            return new Procedure[]{left, right};
        }
    }

    private List<HashMap<Integer, Integer>> dfs(AND_Branch branch, SearchStatistics statistics, Predicate<SearchStatistics> limit, int parentId, int position, boolean A) {

        if (limit.test(statistics))
            throw new StopSearchException();
        final int nodeId = currNodeIdId++;
        if (Objects.equals(branch.getType(), "and")) {
            System.out.println("AND branch");
            notifySolution(parentId,nodeId, position);
            notifyBranch(parentId,nodeId, position, branch.branches.length);
            int pos = 0;
            List<List<HashMap<Integer, Integer>>> liste = new ArrayList<>();
            int a = 0;
            for (AND_Branch b : branch.branches) {
                System.out.println("    branch nÂ° " + a);
                a++;
                final int p = pos;
                sm.withNewState(() -> {
                    try {
                        statistics.incrNodes();
                        List<HashMap<Integer, Integer>> L = dfs(b,statistics, limit, nodeId, p, true);
                        liste.add(L);
                    } catch (InconsistencyException e) {
                        currNodeIdId++;
                        statistics.incrFailures();
                        notifyFailure(parentId,nodeId, p);
                    }
                });
                pos += 1;
            }

            if (A){
                //fusion des liste
                List<HashMap<Integer, Integer>> End = new ArrayList<>();
                return End;
            } else {

                int size = 1;
                for (List<HashMap<Integer, Integer>> l : liste) {
                    size *= l.size();
                }
//                System.out.println("nombre solution :" + size);
//                for (int k = 0; k < size; k++) {
//                    statistics.incrSolutions();
//                    notifySolution(parentId,nodeId, position);
//                }
            }
        } else {
            B_OR or = (B_OR) branch;
            Procedure[] branches = Branching(this.cp, or.variables);
            notifyBranch(parentId,nodeId, position, or.variables.length);
            int pos = 0;
            if (branches.length == 0) {
                if (branch.getBranches() == null){
                    if (A){
                        notifySolution(parentId,nodeId, position);
                        List<HashMap<Integer, Integer>> Solution = new ArrayList<>();
                        HashMap<Integer, Integer> S = new HashMap<>();
                        S.put(123, 123);
                        Solution.add(S);
                        return Solution;
                    } else {
                        statistics.incrSolutions();
                        notifySolution(parentId,nodeId, position);
                    }

                } else {
                    final int p = pos;
                    List<HashMap<Integer, Integer>> Solutions = dfs(branch.getBranches()[0], statistics, limit, nodeId, p, A);
                    if (A){
                        return Solutions;
                    }
                }
            } else {
                List<HashMap<Integer, Integer>> liste = new ArrayList<>();
                for (Procedure b : branches) {
                    final int p = pos;
                    sm.withNewState(() -> {
                        try {
                            statistics.incrNodes();
                            b.call();
                            if (A){
                                liste.addAll(dfs(branch,statistics, limit, nodeId, p, A));
                            } else {
                                dfs(branch,statistics, limit, nodeId, p, A);
                            }

                        } catch (InconsistencyException e) {
                            currNodeIdId++;
                            statistics.incrFailures();
                            notifyFailure(parentId,nodeId, p);
                        }
                    });
                    pos += 1;
                }
                return liste;
            }
        }
        return null;
    }

    public static abstract class AND_Branch {
        private final String type;
        private final AND_Branch[] branches;
        public AND_Branch(String type, AND_Branch[] branches) {
            this.type = type;
            this.branches = branches;
        }
        public String getType() {
            return this.type;
        }
        public AND_Branch[] getBranches() {
            return this.branches;
        }
    }
    public static class B_AND extends AND_Branch {
        public B_AND(AND_Branch[] branches){
            super("and", branches);
        }
    }
    public static class B_OR extends AND_Branch {
        private IntVar[] variables;

        public B_OR(AND_Branch[] branches, IntVar[] variables){
            super("or", branches);
            this.variables = variables;
        }

        public IntVar[] getVariables() {
            return this.variables;
        }
    }
    public static Procedure[] Branching2(Solver cp, IntVar[] Variable) {
        int idx = -1; // index of the first variable that is not fixed
        boolean axe = true;
        for (int k = 0; k < Variable.length; k++)
            if (Variable[k].size() > 1) {
                idx = k;
                break;
            }
        if (idx == -1)
            return new Procedure[0];
        else {
            IntVar qi = Variable[idx];
            int v = qi.min();
            Procedure left = () -> cp.post(Factory.equal(qi, v));
            Procedure right = () -> cp.post(Factory.notEqual(qi, v));
            return new Procedure[]{left, right};
        }
    }
}