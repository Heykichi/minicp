/*
 * mini-cp is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License  v3
 * as published by the Free Software Foundation.
 *
 * mini-cp is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY.
 * See the GNU Lesser General Public License  for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with mini-cp. If not, see http://www.gnu.org/licenses/lgpl-3.0.en.html
 *
 * Copyright (c)  2018. by Laurent Michel, Pierre Schaus, Pascal Van Hentenryck
 */

package minicp.ANDOR_engine;

import minicp.engine.core.IntVar;
import minicp.engine.core.Solver;
import minicp.search.DFSListener;
import minicp.search.SearchStatistics;
import minicp.search.StopSearchException;
import minicp.state.StateManager;
import minicp.util.Procedure;
import minicp.util.exception.InconsistencyException;
import minicp.util.exception.NotImplementedException;

import java.util.*;
import java.util.concurrent.atomic.AtomicReference;
import java.util.function.Function;
import java.util.function.Supplier;

import static minicp.ANDOR_engine.SlicedTable.computeSlicedTable;

/**
 * Depth First Search Branch and Bound implementation
 */
public class AND_DFSearch {

    private Solver cp;
    private StateManager sm;
    private Supplier<Branch> treeBuilding;
    private Function<Set<IntVar>, Procedure[]> branching;

    private List<DFSListener> dfsListeners = new LinkedList<DFSListener>();

    private int currNodeId;

    private boolean complete = true;
    private boolean showSolutions = false;
    private boolean computeSolutions = true;

    /**
     * Creates a Depth First Search object with a given branching
     * that defines the search tree dynamically.
     *
     */

    public AND_DFSearch(Solver cp, Supplier<Branch> treeBuilding, Function<Set<IntVar>, Procedure[]> branching) {
        this.cp = cp;
        this.sm = cp.getStateManager();
        this.treeBuilding = treeBuilding;
        this.branching = branching;
    }

    public void setBranching(Function<Set<IntVar>, Procedure[]> branching) {
        this.branching = branching;
    }

    public void setTreeBuilding(Supplier<Branch> treeBuilding) {
        this.treeBuilding = treeBuilding;
    }

    /**
     * Adds a listener that is called on each solution.
     *
     * @param listener the closure to be called whenever a solution is found
     */
    public void onSolution(Procedure listener) {
        dfsListeners.add(new DFSListener() {
            @Override
            public void solution(int pId, int id, int position) {
                listener.call();
            }
        });
    }

    public void addListener(DFSListener listener) {
        dfsListeners.add(listener);
    }

    /**
     * Adds a listener that is called whenever a failure occurs
     * and the search backtracks.
     * This happensthat when a {@link InconsistencyException} is thrown
     * when executing the closure generated by the branching.
     *
     * @param listener the closure to be called whenever a failure occurs and
     *                 the search need to backtrack
     */
    public void onFailure(Procedure listener) {
        dfsListeners.add(new DFSListener() {
            @Override
            public void fail(int pId, int id, int position) {
                listener.call();
            }
        });
    }

    private void notifySolution() {
        dfsListeners.forEach(l -> l.solution(0, 0, 0));
    }

    private void notifyFailure(int parentId, int nodeId, int position) {
        dfsListeners.forEach(l -> l.fail(parentId, nodeId, position));
    }

    private void notifyBranch(int parentId, int nodeId, int position, int nChilds) {
        dfsListeners.forEach(l -> l.branch(parentId, nodeId, position, nChilds));
    }

    private SearchStatistics solve( SearchStatistics statistics, int solutionsLimit, boolean showSolutions) {
        this.showSolutions = showSolutions;
        currNodeId = 0;
        sm.withNewState(() -> {
            try {
                long debut1 = System.nanoTime();
                Solutions solutions = dfs(statistics, -1, -1, solutionsLimit);
                long fin1 = System.nanoTime();
                List<SlicedTable> slicedTables = solutions.slicedTables;
                long debut2 = System.nanoTime();
                if (!slicedTables.isEmpty()) {
                    statistics.setSlicedTables(slicedTables);
                    if (computeSolutions) {
                        processSolutions(statistics, solutions, slicedTables, solutionsLimit);
                    }
                }
                long fin2 = System.nanoTime();
                System.out.format("\nSearch time : %s ms", (fin1 - debut1) / 1_000_000);
                System.out.format("\nComputation time : %s ms\n", (fin2 - debut2) / 1_000_000);

                if (this.complete) statistics.setCompleted();
            } catch (StopSearchException ignored) {
            } catch (StackOverflowError e) {
                throw new NotImplementedException("dfs with explicit stack needed to pass this test");
            }
        });
        return statistics;
    }

    private void processSolutions(SearchStatistics statistics, Solutions solutions, List<SlicedTable> slicedTables, int solutionsLimit) {
        List<Map<Integer, Integer>> listSolutions = computeSlicedTable(slicedTables, solutionsLimit);
        statistics.setSolutions(listSolutions);
        if (solutions.nSolutions >= 0) statistics.incrSolutions(solutions.nSolutions);
        if (showSolutions){
            Set<IntVar> vars = this.cp.getGraphWithStart().getStateVariables();
            int n_solutions = 0;
            for (Map<Integer, Integer> sol : listSolutions) {
                if (vars.size() != sol.size())
                    throw new RuntimeException("Missing value in a solution, " + vars.size() + " != " + sol.size());
                sm.withNewState(() -> {
                    for (IntVar var : vars) {
                        if (sol.containsKey(var.getId())) {
                            int value = sol.get(var.getId());
                            var.fix(value);
                        } else {
                            throw new RuntimeException("no solution for " + var.getId());
                        }
                    }
                    notifySolution();
                });
                n_solutions++;
                if (n_solutions >= solutionsLimit) {
                    break;
                }
            }
        }
    }

    public SearchStatistics solve(int solutionsLimit, boolean showSolutions, boolean computeSolutions) {
        SearchStatistics statistics = new SearchStatistics();
        this.computeSolutions = computeSolutions;
        return solve(statistics, solutionsLimit, showSolutions);
    }

    public SearchStatistics solve(int solutionsLimit, boolean showSolutions) {
        SearchStatistics statistics = new SearchStatistics();
        return solve(statistics, solutionsLimit, showSolutions);
    }

    public SearchStatistics solve(int solutionsLimit) {
        SearchStatistics statistics = new SearchStatistics();
        return solve(statistics, solutionsLimit, true);
    }

    public SearchStatistics solve(boolean showSolutions) {
        SearchStatistics statistics = new SearchStatistics();
        return solve(statistics, Integer.MAX_VALUE, showSolutions);
    }

    public SearchStatistics solve() {
        SearchStatistics statistics = new SearchStatistics();
        return solve(statistics, Integer.MAX_VALUE, true);
    }

    public Map<Integer, Integer> getPattern() {
        Map<Integer, Integer> pattern = new HashMap<>();
        for (IntVar vars : this.cp.getGraphWithStart().getStateVariables()){
            if (vars.isFixed()) {
                pattern.put(vars.getId(),vars.min());
            }
        }
        if (pattern.isEmpty()) return null;
        return pattern;
    }

    public record Solutions(int nSolutions, List<SlicedTable> slicedTables) {}

    private Solutions dfs(SearchStatistics statistics, int parentId, int position, int solutionsLimit) {
        Objects.requireNonNull(this.branching, "No branching instruction");
        Objects.requireNonNull(this.treeBuilding, "No tree building instruction");

        Branch branch = treeBuilding.get();
        if (branch == null) {
            throw new RuntimeException("treeBuilding doesn't give any proposition");
        }

        Solutions solutions;
        if (branch.getVariables() != null && !branch.getVariables().isEmpty()) {
//            System.out.println("OR");
            solutions = processOrBranch(branch, statistics, parentId, position, solutionsLimit);
        } else if (branch.getBranches() != null && !branch.getBranches().isEmpty()){
//            System.out.println("AND");
            solutions = processAndBranch(branch, statistics, parentId, position, solutionsLimit);
        } else {
            throw new IllegalArgumentException("No branch available");
        }
        return solutions;
    }

    private Solutions processAndBranch(Branch branch, SearchStatistics statistics, int parentId, int position, int solutionsLimit){
        statistics.incrAndNodes();
        final int nodeId = currNodeId++;
        int pos = 0;
        final int[] nSolutions = {1};
        List<List<SlicedTable>> subSolutions = new ArrayList<>();
        AtomicReference<Boolean> breaking = new AtomicReference<>(false);
        for (SubBranch B : branch.getBranches()) {
            final int p = pos;
            sm.withNewState(() -> {
                this.cp.getGraphWithStart().newState(B.getVariables());
                Solutions newST ;
                int limit = solutionsLimit;
                if (solutionsLimit != Integer.MAX_VALUE) {
                    if (nSolutions[0] >= solutionsLimit) {
                        limit = 1;
                    } else if (nSolutions[0] > 1) {
                        limit = (int) Math.ceil((double) solutionsLimit / nSolutions[0]);
                    }
                }
                if (B.getToFix()) {
                    newST = processOrBranch(new Branch(B.getVariables()), statistics, nodeId, position, limit);
                    if (this.complete) statistics.setCompleted();
                } else {
                    newST = dfs(statistics, nodeId, p, limit);
                }
                if (newST!= null && !newST.slicedTables.isEmpty()) {
                    subSolutions.add(newST.slicedTables);
                    nSolutions[0] *= newST.nSolutions;
                } else {
                    breaking.set(true);
                }
            });
            if (breaking.get()) {
                return null;
            }
            pos += 1;
        }
        return new Solutions(nSolutions[0], new ArrayList<SlicedTable>(List.of(new SlicedTable(getPattern(), subSolutions))));
    }

    private Solutions processOrBranch(Branch branch, SearchStatistics statistics, int parentId, int position, int solutionsLimit){
        final int nodeId = currNodeId++;
        Procedure[] branches = new Procedure[0];
        if (branch.getVariables() != null){
            branches = this.branching.apply(branch.getVariables());
            notifyBranch(parentId,nodeId, position, branch.getVariables().size());
        }
        int pos = 0;
        List<SlicedTable> sols = new ArrayList<>();
        if (branches.length == 0) {
            // SOLUTION
            if (cp.getGraphWithStart().solutionFound()){
                sols.add(new SlicedTable(getPattern()));
                return new Solutions(1, sols);
            } else if (branch.getBranches() == null){
                Solutions newST = dfs(statistics, nodeId, pos, solutionsLimit);
                if (!newST.slicedTables.isEmpty()) {
                    return newST;
                }
            } else {
                final int p = pos;
                Solutions newST = processAndBranch(new Branch(branch.getBranches()), statistics, nodeId, p, solutionsLimit);
                if (newST != null) {
                    return newST;
                }
            }
            return null;
        } else {
            final int[] nSolutions = {0};
            for (Procedure b : branches) {
                if (sols.size() >= solutionsLimit) {
                    this.complete = false;
                    break;
                }
                final int p = pos;
                sm.withNewState(() -> {
                    try {
                        statistics.incrNodes();
                        b.call();
                        int limite = solutionsLimit;
                        if (solutionsLimit != Integer.MAX_VALUE) {
                            limite = solutionsLimit-nSolutions[0];
                        }
                        Solutions newST = processOrBranch(branch,statistics, nodeId, p, limite);
                        if (newST != null) {
                            sols.addAll(newST.slicedTables);
                            nSolutions[0] += newST.nSolutions;
                        }
                    } catch (InconsistencyException e) {
                        currNodeId++;
                        statistics.incrFailures();
                        notifyFailure(parentId,nodeId, p);
                    }
                });
                pos += 1;
            }
            return new Solutions(nSolutions[0], sols);
        }
    }
}