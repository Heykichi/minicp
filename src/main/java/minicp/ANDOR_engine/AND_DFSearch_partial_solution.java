/*
 * mini-cp is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License  v3
 * as published by the Free Software Foundation.
 *
 * mini-cp is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY.
 * See the GNU Lesser General Public License  for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with mini-cp. If not, see http://www.gnu.org/licenses/lgpl-3.0.en.html
 *
 * Copyright (c)  2018. by Laurent Michel, Pierre Schaus, Pascal Van Hentenryck
 */

package minicp.ANDOR_engine;

import minicp.cp.Factory;
import minicp.engine.core.IntVar;
import minicp.engine.core.Solver;
import minicp.search.DFSListener;
import minicp.search.SearchStatistics;
import minicp.search.StopSearchException;
import minicp.state.StateManager;
import minicp.util.Procedure;
import minicp.util.exception.InconsistencyException;
import minicp.util.exception.NotImplementedException;

import java.util.LinkedList;
import java.util.List;
import java.util.concurrent.atomic.AtomicReference;
import java.util.function.Predicate;
import java.util.function.Supplier;

import static java.lang.Math.max;

/**
 * Depth First Search Branch and Bound implementation
 */
public class AND_DFSearch_partial_solution {

    private Solver cp;
    private Supplier<Branch> branching = null;
    private StateManager sm;
    private ConstraintGraph graph;


    private List<DFSListener> dfsListeners = new LinkedList<DFSListener>();


    private int currNodeIdId;

    /**
     * Creates a Depth First Search object with a given branching
     * that defines the search tree dynamically.
     *
     */

    public AND_DFSearch_partial_solution(Solver cp, Supplier<Branch> branching) {
        this.cp = cp;
        this.sm = cp.getStateManager();
        this.branching = branching;
        this.graph = cp.getGraph();
    }
    // REMOVE
    public AND_DFSearch_partial_solution(Solver cp) {
        this.cp = cp;
        this.sm = cp.getStateManager();
        this.graph = cp.getGraph();
    }

    /**
     * Adds a listener that is called on each solution.
     *
     * @param listener the closure to be called whenever a solution is found
     */
    public void onSolution(Procedure listener) {
        dfsListeners.add(new DFSListener() {
            @Override
            public void solution(int pId, int id, int position) {
                listener.call();
            }
        });
    }


    public void addListener(DFSListener listener) {
        dfsListeners.add(listener);
    }

    /**
     * Adds a listener that is called whenever a failure occurs
     * and the search backtracks.
     * This happensthat when a {@link InconsistencyException} is thrown
     * when executing the closure generated by the branching.
     *
     * @param listener the closure to be called whenever a failure occurs and
     *                 the search need to backtrack
     */
    public void onFailure(Procedure listener) {
        dfsListeners.add(new DFSListener() {
            @Override
            public void fail(int pId, int id, int position) {
                listener.call();
            }
        });
    }


    private void notifySolution(int parentId, int nodeId, int position) {
        dfsListeners.forEach(l -> l.solution(parentId, nodeId, position));
    }

    private void notifyFailure(int parentId, int nodeId, int position) {
        dfsListeners.forEach(l -> l.fail(parentId, nodeId, position));
    }

    private void notifyBranch(int parentId, int nodeId, int position, int nChilds) {
        dfsListeners.forEach(l -> l.branch(parentId, nodeId, position, nChilds));
    }

    private SearchStatistics solve( SearchStatistics statistics, Predicate<SearchStatistics> limit) {
        currNodeIdId = 0;
        sm.withNewState(() -> {
            try {
                int n_Solutions = dfs(null,statistics, limit , -1, -1,0);
                for (int i = 0; i < n_Solutions; i++) {
                    statistics.incrSolutions();
                }
                statistics.setCompleted();
            } catch (StopSearchException ignored) {
            } catch (StackOverflowError e) {
                throw new NotImplementedException("dfs with explicit stack needed to pass this test");
            }
        });
        return statistics;
    }

    public SearchStatistics solve(Predicate<SearchStatistics> limit) {
        SearchStatistics statistics = new SearchStatistics();
        return solve(statistics, limit);
    }

    public SearchStatistics solve() {
        SearchStatistics statistics = new SearchStatistics();
        return solve(statistics, stats -> false);
    }

    private Procedure[] branching(Solver cp, IntVar[] Variable) {
        if (Variable == null || Variable.length == 0){
            return new Procedure[0];
        }
        int idx = -1; // index of the first variable that is not fixed
        for (int k = 0; k < Variable.length; k++)
            if (Variable[k].size() > 1) {
                idx = k;
                break;
            }
        if (idx == -1)
            return new Procedure[0];
        else {
            IntVar qi = Variable[idx];
            int v = qi.min();
            Procedure left = () -> cp.post(Factory.equal(qi, v));
            Procedure right = () -> cp.post(Factory.notEqual(qi, v));
            return new Procedure[]{left, right};
        }
    }

    // TODO CHECK NOTIFYBRANCH => CALCULE NODE/CHOICE + LIMITE
    private int dfs(Branch B, SearchStatistics statistics, Predicate<SearchStatistics> limit, int parentId, int position, int AndLevel) {

        if (limit.test(statistics))
            throw new StopSearchException();
        if (this.branching == null & B == null){
            throw new IllegalArgumentException("No branching instruction");
        }
        Branch branch = (B != null ) ? B :branching.get();
        if (branch == null) {
            return -1;
        }
        // check multiple rebranching (only 1 depth)
        int count = branch.getRebranching() ? 1 : 0;
        if (branch.getBranches() != null) {
            for (Branch sub : branch.getBranches()) {
                if (sub.getRebranching()) count ++; // early exit
            }
        }
        if (count > 1) {throw new IllegalArgumentException("Multiple rebranching not supported");}

        // TODO GESTION SOLUTION
        int n_Solutions = 0;

        if (branch.getVariables() == null & branch.getBranches() != null){
//            System.out.println("AND");
            n_Solutions = (processAndBranch(branch, statistics, limit, parentId, position, AndLevel));

        } else if (branch.getVariables() != null) {
//            System.out.println("OR");
            n_Solutions = processOrBranch(branch, statistics, limit, parentId, position, AndLevel);
        } else {
            throw new IllegalArgumentException("No branch available");
        }
        return n_Solutions;
    }
    // TODO SPLIT + GESTION SOLUTION => oui d'un coté et non de l'autre => check
    private int processAndBranch(Branch branch, SearchStatistics statistics, Predicate<SearchStatistics> limit, int parentId, int position, int AndLevel){
        final int nodeId = currNodeIdId++;
        System.out.println("AND branch of depth "+AndLevel+" =================================================");
        notifySolution(parentId,nodeId, position);
        notifyBranch(parentId,nodeId, position, branch.getBranches().length);
        int pos = 0;
        // TODO compute pattern
        final int[] n_Solutions = {1};
        int a = 0;
        AtomicReference<Boolean> breaking = new AtomicReference<>(false);
        for (Branch b : branch.getBranches()) {
            System.out.println("Depth "+ AndLevel +", subbranch n° " + (a+1) + " \t----------------------");
            a++;
            final int p = pos;
            sm.withNewState(() -> {
                try {
                    //statistics.incrNodes();
                    int solution = processOrBranch(b,statistics, limit, nodeId, p, AndLevel+1);
                    if (solution == 0) breaking.set(true);
                    n_Solutions[0] *= solution;
                } catch (InconsistencyException e) {
                    currNodeIdId++;
                    statistics.incrFailures();
                    notifyFailure(parentId,nodeId, p);
                }
            });
            if (breaking.get()) break;
            pos += 1;
        }
        if (branch.getRebranching() & !breaking.get() & n_Solutions[0] > 0) {
            System.out.println("Depth "+ AndLevel +", subbranch n° " + (a+1) + " test rebranching\t------");
            final int p = pos;
            sm.withNewState(() -> {
                try {
                    //statistics.incrNodes();
                    int next = dfs(null,statistics, limit , nodeId, p,AndLevel+1);
                    if (next != -1) {
                        n_Solutions[0] *= next;
                    }
                } catch (InconsistencyException e) {
                    currNodeIdId++;
                    statistics.incrFailures();
                    notifyFailure(parentId,nodeId, p);
                }
            });
        }
        return n_Solutions[0];
    }

    private int processOrBranch(Branch branch, SearchStatistics statistics, Predicate<SearchStatistics> limit, int parentId, int position, int AndLevel){
        final int nodeId = currNodeIdId++;

        Procedure[] branches = new Procedure[0];
        if (branch.getVariables() != null){
            branches = branching(this.cp, branch.getVariables());
            notifyBranch(parentId,nodeId, position, branch.getVariables().length);
            //System.out.println(branches.length);
        }
        int pos = 0;
        if (branches.length == 0) {
            // TODO CHECK SUITE
            // SOLUTION
            if (branch.getBranches() == null){
                if (branch.getRebranching()){
                    final int p = pos;
                    int next = dfs(null,statistics, limit , nodeId, p,AndLevel);

                    if (next != -1) {
                        return next;
                    }
                }
                notifySolution(parentId,nodeId, position);
                return 1;
            } else {
                // TODO START SUB BRANCH + GET SOLUTION
                final int p = pos;
                return processAndBranch(branch, statistics, limit, nodeId, p, AndLevel);

            }
        } else {
            // TODO GESTION SOLUTION
            final int[] n_Solutions = {0};
            for (Procedure b : branches) {
                final int p = pos;
                sm.withNewState(() -> {
                    try {
                        statistics.incrNodes();
                        b.call();
                        n_Solutions[0] += processOrBranch(branch,statistics, limit, nodeId, p, AndLevel);

                    } catch (InconsistencyException e) {
                        currNodeIdId++;
                        statistics.incrFailures();
                        notifyFailure(parentId,nodeId, p);
                    }
                });
                pos += 1;
            }
            return n_Solutions[0];
        }
    }
}